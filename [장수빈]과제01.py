# -*- coding: utf-8 -*-
"""[장수빈]과제01.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1gtTSF5_YjyEjmjiPaKUuymP0Zkv1kK2w

# 1주차 과제

## 가변 배열 구현
가변적인 크기를 가지는 배열을 구현해야합니다.  
동적할당을 이용하여 가변 배열 클래스를 만들어보세요.  
지원해야하는 연산은 다음과 같습니다.

1. push_back(T data) : 현재 가변 배열 뒤에 원소를 삽입
2. pop_back() : 현재 가변 배열 뒤의 원소를 삭제
3. insert(Iterator index, T data): 가변 배열의 index위치에 원소를 삽입합니다. index위치의 원소를 포함하여 (k> index) 위치에 있는 원소들은 뒤로 밀립니다.
4. delete(Iterator index): 가변 배열의 index위치에 있는 원소를 삭제합니다.
5. at(Iterator i): 인덱스에 존재하는 원소의 레퍼런스(or 포인터)를 반환합니다.
6. size(): 현재 가변배열의 길이를 반환합니다.
7. clear(): 가변 배열을 초기화합니다.
"""

# 파이썬은 모든 것이 객체이다. 파이썬은 동적 할당의 기능이 없다. 즉, 사용자가 직접 메모리 할당 범위를 조정하지 않는다.
class DynamicArray:
  def __init__(self):
    self.arr = []

  def push_back(self, data):# 가변배열 뒤에 원소 삽입
    self.arr.append(data)
    print(self.arr)

  def pop_back(self): # 가변배열 뒤 원소 삭제
    self.arr.pop()
    print(self.arr)

  def insert(self, index, data): # 특정 index에 원소 삽입
    if (index <= len(self.arr)):
      temp1 = self.arr[:index]
      temp2 = self.arr[index:]
      temp1.append(data)
      self.arr = temp1+temp2
      print(self.arr)
    else:
      print("인덱스가 범위를 벗어났습니다. ")

  def delete(self, index): # 특정 index의 원소 삭제
    if (index <= len(self.arr)):
      temp1 = self.arr[:index]
      temp2 = self.arr[index+1:]
      self.arr = temp1 + temp2
      print(self.arr)
    else:
      print("인덱스가 범위를 벗어났습니다.")

  def at(self, i): # 인덱스에 존재하는 원소의 레퍼런스 반환
    return print(id(self.arr[i]))

  def size(self): # 현재 길이 반환
    return print(len(self.arr))

  def clear(self): # 초기화
    self.arr = []
    print("clear")

  def printf(self):
    return print(self.arr)

## __main__ ##
array = DynamicArray()
array.printf()
array.push_back(3)
array.push_back(6)
array.push_back(9)
array.push_back(12)
array.insert(2,1)
array.pop_back()
array.delete(0)
array.at(2)
array.size()
array.clear()

"""## 연결 리스트 구현
(필수) 단일 연결 리스트  
(필수) 이중 연결 리스트  
(선택) Circular Doubly linked list  
각각의 연결 리스트는 아래와 같은 연산을 지원해야합니다.

1. push_back(Data data): 연결 리스트의 tail에 data를 삽입합니다.
2. push_front(Data data): 연결 리스트의 head에 data를 삽입합니다.
3. insert(Iterator it, Data data): it위치에 data를 삽입합니다.
4. insert(Iterator it, Data data[]): it위치에 data들을 삽입합니다.
5. front(), back(): 각각은 연결리스트의 head의 값과, tail의 값을 리턴합니다.
6. delete(Iterator it): it 위치의 데이터를 삭제합니다.
7. delete(Iterator it, Number count): it 위치의 데이터를 count개만큼 삭제합니다.
8. size(): 연결리스트에 존재하는 모든 노드의 수를 구합니다.
"""

from multipledispatch import dispatch #오버로딩이 안되는 파이썬에 가능하게 만듦

class Node:
  def __init__(self, data):
    self.data = data
    self.next = None

class Single_Linked_List:
  def __init__(self):
    self.head = None
    self.size = 0

  def push_back(self, data): # 연결 리스트의 tail에 data 삽입
    node = Node(data)
    if self.head is None:
      self.head = node
    else:
      prev = self.head
      while prev.next:
        prev = prev.next
      prev.next = node
    self.size += 1

  def push_front(self, data): # 연결 리스트의 head에 data 삽입
    node = Node(data)
    if self.head is None:
       self.head = node
    else:
      node.next = self.head
      self.head = node
    self.size += 1

  def insert(self, it, data): # it 위치에 data 삽입
    if (it <= 0):
      self.push_front(data)
    elif (0 < it < self.size):
      prev = self.head
      for i in range(it-1):
        prev = prev.next
      node = Node(data)
      node.next = prev.next
      prev.next = node
      self.size += 1
    else:
      print("인덱스 값이 범위를 벗어났습니다.")

  def insert(self, it, *data): # it 위치들에 data들 삽입 # *은 여러개의 인자값을 받을 수 있도록함
    for i in range(len(data)):
      if (it <= 0):
        self.push_front(data[i])
      elif (0 < it < self.size):
        prev = self.head
        for i in range(it-1):
          prev = prev.next
        node = Node(data[i])
        node.next = prev.next
        prev.next = node
        self.size += 1
      else:
        print("인덱스 값이 범위를 벗어났습니다.")

  @dispatch(int)
  def delete(self, it):# it 위치의 data 삭제
    if (it == 0):
      self.head = self.head.next
      self.size -= 1
    elif ( 1 <= it < self.size):
      prev = self.head
      for i in range(it-1):
        prev = prev.next
      prev.next = prev.next.next
      self.size -= 1
    else:
      print("인덱스 값이 범위를 벗어났습니다.")

  @dispatch(int, int)
  def delete(self, it, count): # it 위치부터 data들 count갯수만큼 삭제
    for i in range(count):
      if (it == 0):
        self.head = self.head.next
        self.size -= 1
      elif ( 1 <= it < self.size):
        prev = self.head
        for i in range(it-1):
          prev = prev.next
        prev.next = prev.next.next
        self.size -= 1
      else:
        print("인덱스 값이 범위를 벗어났습니다.")

  def front(self): # head값 리턴
    return print("head:", self.head.data)

  def back(self): # tail값 리턴
    tail = self.head
    for i in range(self.size-1):
      tail = tail.next
    return print("tail:", tail.data)

  def get_size(self): # 연결된 size 리턴
    return print("size: ", self.size)


## __main__ ##
linklist = Single_Linked_List()
linklist.push_back(3) #추가
linklist.push_front(1) #추가
linklist.get_size() #2
linklist.insert(1, 2) #추가
linklist.push_front(0) #추가
linklist.push_back(7) #추가
linklist.front()
linklist.back()
linklist.get_size() #5
linklist.delete(2) #삭제
linklist.delete(0, 2) #삭제
linklist.front()
linklist.back()
linklist.get_size() #2
linklist.insert(0, 1, 2, 3, 4, 5, 6) #추가*6
linklist.front()
linklist.back()
linklist.get_size() #8

from multipledispatch import dispatch #오버로딩이 안되는 파이썬에 가능하게 만듦

class Node(object):
  def __init__(self, data, prev = None, next = None):
    self.data = data
    self.prev = prev
    self.next = next

class Double_Linked_List2(object):
  def __init__(self):
    self.head = Node(None)
    self.tail = Node(None, self.head)
    self.head.next = self.tail
    self.size = 0

  def selectNode(self, idx): # idx에 따른 노드 찾기
    if idx > self.size:
      print("인덱스 값이 범위를 벗어났습니다.")
      return None
    if idx == 0:
      return self.head
    if idx == self.size:
      return self.tail
    if idx <= self.size//2:
      target = self.head
      for _ in range(idx):
          target = target.next
      return target
    else:
      target = self.tail
      for _ in range(self.size - idx):
          target = target.prev
      return target

  def push_back(self, data): # tail에 노드 추가
    if self.size == 0:
      self.head = Node(data)
      self.tail = Node(None, self.head)
      self.head.next = self.tail
    else:
      tmp = self.tail.prev
      newNode = Node(data, tmp, self.tail)
      tmp.next = newNode
      self.tail.prev = newNode
    self.size += 1

  def push_front(self, data): # head에 노드 추가
    if self.size == 0:
      self.head = Node(data)
      self.tail = Node(None, self.head)
      self.head.next = self.tail
    else:
      tmp = self.head
      self.head = Node(data, None, self.head)
      tmp.prev = self.head
    self.size += 1

  def insert(self, idx, data): # idx에 노드 추가
    if self.size == 0:
      self.head = Node(data)
      self.tail = Node(None, self.head)
      self.head.next = self.tail
    else:
      tmp = self.selectNode(idx)
      if tmp == None:
        return
      if tmp == self.head:
        self.push_front(data)
      elif tmp == self.tail:
        self.push_back(data)
      else:
        tmp_prev = tmp.prev
        newNode = Node(data, tmp_prev, tmp)
        tmp_prev.next = newNode
        tmp.prev = newNode
    self.size += 1

  def insert(self, idx, *data): # idx에 노드들 추가
    for i in range(len(data)):
      if self.size == 0:
        self.head = Node(data[i])
        self.tail = Node(None, self.head)
        self.head.next = self.tail
      else:
        tmp = self.selectNode(idx)
        if tmp == None:
            return
        if tmp == self.head:
            self.push_front(data[i])
        elif tmp == self.tail:
            self.push_back(data[i])
        else:
            tmp_prev = tmp.prev
            newNode = Node(data[i], tmp_prev, tmp)
            tmp_prev.next = newNode
            tmp.prev = newNode
      self.size += 1

  @dispatch(int)
  def delete(self, idx): # idx의 노드 삭제
    if self.size == 0:
      print("더이상 삭제할 노드가 없습니다")
      return
    else:
      tmp = self.selectNode(idx)
      if tmp == None:
        return
      elif tmp == self.head:
        tmp = self.head
        self.head = self.head.next
      elif tmp == self.tail:
        tmp = self.tail
        self.tail = self.tail.prev
      else:
        tmp.prev.next = tmp.next
        tmp.next.prev = tmp.prev
      del(tmp)
      self.size -= 1

  @dispatch(int, int)
  def delete(self, idx, count): # idx의 노드 삭제
    for i in range(count):
      if self.size == 0:
        print("더이상 삭제할 노드가 없습니다.")
        return
      else:
        tmp = self.selectNode(idx)
        if tmp == None:
          return
        elif tmp == self.head:
          tmp = self.head
          self.head = self.head.next
        elif tmp == self.tail:
          tmp = self.tail
          self.tail = self.tail.prev
        else:
          tmp.prev.next = tmp.next
          tmp.next.prev = tmp.prev
        del(tmp)
        self.size -= 1

  def front(self): # head값 리턴
    return print("head:", self.head.data)

  def back(self): # tail값 리턴
    return print("tail:", self.tail.prev.data)

  def get_size(self): # size값 리턴
    return print("size: ", self.size)

  def printlist(self): # 전체 list 프린트
    target = self.head
    while target != self.tail:
      if target.next != self.tail:
        print(target.data, '<=> ', end='')
      else:
        print(target.data)
      target = target.next

## __main__ ##
mylist = Double_Linked_List2()
mylist.push_back('A')
mylist.printlist()
mylist.push_back('B')
mylist.printlist()
mylist.push_back('C')
mylist.printlist()
mylist.insert(1, 'D')
mylist.printlist()
mylist.push_front('E')
mylist.printlist()
mylist.get_size()
mylist.delete(0)
mylist.printlist()
mylist.delete(3)
mylist.printlist()
mylist.delete(0)
mylist.printlist()
mylist.insert(1, 'a', 'b', 'c')
mylist.printlist()
mylist.front()
mylist.back()
mylist.get_size()

"""## stack 구현
Stack은 First In, Last Out이라는 특성을 가지는 자료구조입니다.  
앞에서 구현했던 가변 배열, 연결 리스트 방식으로 Stack을 구현해보세요!  
지원해야하는 연산은 아래와 같습니다.  

1. push(Data data): stack에 data삽입
2. top(): stack의 top에 있는 원소를 출력 (삭제가 아니다)
3. pop(): stack의 top에 있는 원소를 삭제한다.
-> 모두 O(1)
"""

class Stack:
  def __init__(self):
    self.stack = []

  def push(self, data):# stack 뒤에 원소 삽입
    self.stack.append(data)
    print(self.stack)

  def top(self):
    print(self.stack[-1])

  def pop(self): # stack 뒤 원소 삭제
    self.stack.pop()
    print(self.stack)


## __main__ ##
stack = Stack()
stack.push(2)
stack.push(4)
stack.push(6)
stack.top()
stack.pop()
stack.top()

"""## Queue 구현
Queue는 First In, First Out이라는 특성을 가지는 자료구조입니다.  
앞에서 구현했던 가변배열, 연결 리스트 방식으로 Queue를 구현해보세요!  
지원해야하는 연산은 아래와 같습니다.  

1. push(Data data): queue에 data 삽입
2. front(): queue의 front에 있는 원소를 출력 (삭제가 아니다)
3. pop(): queue의 front에 있는 원소를 삭제한다
-> 모두 O(1)
"""

class Queue:
  def __init__(self):
    self.queue = []

  def push(self, data):
    temp = [data]
    self.queue = temp + self.queue
    print(self.queue)

  def front(self):
    print(self.queue[-1])

  def pop(self):
    self.queue.pop()


## __main__ ##
queue = Queue()
queue.push(5)
queue.push(10)
queue.push(15)
queue.push(20)
queue.front()
queue.pop()
queue.pop()
queue.push(25)
queue.front()